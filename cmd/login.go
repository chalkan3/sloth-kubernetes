package cmd

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"syscall"

	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"golang.org/x/crypto/ssh/terminal"
)

var loginCmd = &cobra.Command{
	Use:   "login",
	Short: "Configure cloud provider credentials",
	Long: `Configure and securely store cloud provider API tokens.

This command interactively prompts for your cloud provider credentials and
stores them in ~/.sloth-kubernetes/credentials for future use.

Supported providers:
  - DigitalOcean (DIGITALOCEAN_TOKEN)
  - Linode (LINODE_TOKEN)

The credentials are stored with restricted file permissions (0600) for security.

Example:
  sloth-kubernetes login
  sloth-kubernetes login --provider digitalocean
  sloth-kubernetes login --provider linode`,
	RunE: runLogin,
}

var (
	loginProvider string
	loginOverwrite bool
)

func init() {
	rootCmd.AddCommand(loginCmd)
	loginCmd.Flags().StringVarP(&loginProvider, "provider", "p", "", "Provider to configure (digitalocean, linode, or leave empty for all)")
	loginCmd.Flags().BoolVar(&loginOverwrite, "overwrite", false, "Overwrite existing credentials without prompting")
}

func runLogin(cmd *cobra.Command, args []string) error {
	fmt.Println()
	color.Cyan("üîê Cloud Provider Login")
	fmt.Println()

	// Get or create credentials directory
	credsDir, err := getCredentialsDir()
	if err != nil {
		return fmt.Errorf("failed to get credentials directory: %w", err)
	}

	credsFile := filepath.Join(credsDir, "credentials")

	// Load existing credentials
	existing, err := loadCredentials(credsFile)
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to load existing credentials: %w", err)
	}

	// Determine which providers to configure
	providers := []string{}
	if loginProvider != "" {
		providers = append(providers, strings.ToLower(loginProvider))
	} else {
		providers = []string{"digitalocean", "linode"}
	}

	// Configure each provider
	for _, provider := range providers {
		if err := configureProvider(provider, existing); err != nil {
			return err
		}
	}

	// Save credentials
	if err := saveCredentials(credsFile, existing); err != nil {
		return fmt.Errorf("failed to save credentials: %w", err)
	}

	fmt.Println()
	color.Green("‚úì Credentials saved successfully!")
	fmt.Printf("  Location: %s\n", credsFile)
	fmt.Println()
	color.Yellow("Note: You can now deploy clusters without setting environment variables.")
	fmt.Println()

	return nil
}

func configureProvider(provider string, creds map[string]string) error {
	var envVar string
	var displayName string

	switch provider {
	case "digitalocean", "do":
		envVar = "DIGITALOCEAN_TOKEN"
		displayName = "DigitalOcean"
	case "linode":
		envVar = "LINODE_TOKEN"
		displayName = "Linode"
	default:
		return fmt.Errorf("unsupported provider: %s (supported: digitalocean, linode)", provider)
	}

	// Check if already configured
	if existing, ok := creds[envVar]; ok && !loginOverwrite {
		fmt.Printf("%s token already configured: %s\n", displayName, maskToken(existing))
		if !promptYesNo(fmt.Sprintf("  Overwrite %s token?", displayName)) {
			fmt.Printf("  Skipping %s\n", displayName)
			return nil
		}
	}

	// Prompt for token
	token, err := promptToken(fmt.Sprintf("Enter %s API token", displayName))
	if err != nil {
		return err
	}

	if token == "" {
		fmt.Printf("  Skipping %s (no token provided)\n", displayName)
		return nil
	}

	creds[envVar] = token
	color.Green("  ‚úì %s token configured", displayName)

	return nil
}

func getCredentialsDir() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	credsDir := filepath.Join(home, ".sloth-kubernetes")

	// Create directory if it doesn't exist
	if err := os.MkdirAll(credsDir, 0700); err != nil {
		return "", err
	}

	return credsDir, nil
}

func loadCredentials(path string) (map[string]string, error) {
	creds := make(map[string]string)

	file, err := os.Open(path)
	if err != nil {
		return creds, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		parts := strings.SplitN(line, "=", 2)
		if len(parts) == 2 {
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			// Remove quotes if present
			value = strings.Trim(value, `"'`)
			creds[key] = value
		}
	}

	return creds, scanner.Err()
}

func saveCredentials(path string, creds map[string]string) error {
	// Create file with restricted permissions
	file, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write header
	fmt.Fprintln(file, "# Sloth Kubernetes Cloud Provider Credentials")
	fmt.Fprintln(file, "# This file contains sensitive API tokens - keep it secure!")
	fmt.Fprintln(file, "# File permissions: 0600 (read/write for owner only)")
	fmt.Fprintln(file, "#")
	fmt.Fprintf(file, "# Generated by: sloth-kubernetes login\n")
	fmt.Fprintln(file, "")

	// Write credentials in order
	for _, key := range []string{"DIGITALOCEAN_TOKEN", "LINODE_TOKEN"} {
		if value, ok := creds[key]; ok && value != "" {
			fmt.Fprintf(file, "%s=%s\n", key, value)
		}
	}

	return nil
}

func promptToken(prompt string) (string, error) {
	fmt.Printf("%s (hidden): ", prompt)

	byteToken, err := terminal.ReadPassword(int(syscall.Stdin))
	fmt.Println() // New line after hidden input
	if err != nil {
		return "", fmt.Errorf("failed to read token: %w", err)
	}

	return strings.TrimSpace(string(byteToken)), nil
}

func promptYesNo(prompt string) bool {
	reader := bufio.NewReader(os.Stdin)
	fmt.Printf("%s (y/N): ", prompt)

	response, err := reader.ReadString('\n')
	if err != nil {
		return false
	}

	response = strings.ToLower(strings.TrimSpace(response))
	return response == "y" || response == "yes"
}

func maskToken(token string) string {
	if len(token) <= 8 {
		return "****"
	}
	return token[:4] + "..." + token[len(token)-4:]
}
